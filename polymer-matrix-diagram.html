<!--
	POLYMER-MATRIX-DIAGRAM

	DESCRIPTION:
		- `polymer-matrix-diagram` is a UI element for displaying matrix diagrams.

	EXAMPLE:
		<polymer-matrix-diagram id="chart"></polymer-matrix-diagram>
		...
		var chart = this.$.chart;

	@element polymer-matrix-diagram
	@status unstable
--><!-- POLYMER --><html><head><link rel="import" href="../polymer/polymer.html">

<!-- DEPENDENCIES -->
<link rel="import" href="../polymer-uuid/polymer-uuid.html">
<link rel="import" href="../polymer-d3/polymer-d3.html">

<!-- ELEMENT -->
</head><body><polymer-element name="polymer-matrix-diagram" attributes="data rowOrder colOrder config width height paddingLeft paddingRight paddingBottom paddingTop xLabel yLabel zValue zMin zMax cScale duration autoResize autoUpdate" assetpath="build/">

	<template>

		<!-- STYLESHEETS -->
		<style>/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}</style>
		<style>/* COLORS */

[data-color="basic-vertex"] {
	fill: #474747;
}

[data-color="basic-edge"] {
	stroke: #474747;
}

/* D3: Category10 */
.category10-1,
[data-color="category10-1"] {
	fill: #1f77b4;
}
.category10-2,
[data-color="category10-2"] {
	fill: #ff7f0e;
}
.category10-3,
[data-color="category10-3"] {
	fill: #2ca02c;
}
.category10-4,
[data-color="category10-4"] {
	fill: #d62728;
}
.category10-5,
[data-color="category10-5"] {
	fill: #9467bd;
}
.category10-6,
[data-color="category10-6"] {
	fill: #8c564b;
}
.category10-7,
[data-color="category10-7"] {
	fill: #e377c2;
}
.category10-8,
[data-color="category10-8"] {
	fill: #7f7f7f;
}
.category10-9,
[data-color="category10-9"] {
	fill: #bcdb22;
}
.category10-10,
[data-color="category10-10"] {
	fill: #17becf;
}

/* D3: category20 */
.category20-1,
[data-color="category20-1"] {
	fill: #1f77b4;
}
.category20-2,
[data-color="category20-2"] {
	fill: #aec7e8;
}
.category20-3,
[data-color="category20-3"] {
	fill: #ff7f0e;
}
.category20-4,
[data-color="category20-4"] {
	fill: #ffbb78;
}
.category20-5,
[data-color="category20-5"] {
	fill: #2ca02c;
}
.category20-6,
[data-color="category20-6"] {
	fill: #98df8a;
}
.category20-7,
[data-color="category20-7"] {
	fill: #d62728;
}
.category20-8,
[data-color="category20-8"] {
	fill: #ff9896;
}
.category20-9,
[data-color="category20-9"] {
	fill: #9467bd;
}
.category20-10,
[data-color="category20-10"] {
	fill: #c5b0d5;
}
.category20-11,
[data-color="category20-11"] {
	fill: #8c564b;
}
.category20-12,
[data-color="category20-12"] {
	fill: #c49c94;
}
.category20-13,
[data-color="category20-13"] {
	fill: #e377c2;
}
.category20-14,
[data-color="category20-14"] {
	fill: #f7b6d2;
}
.category20-15,
[data-color="category20-15"] {
	fill: #7f7f7f;
}
.category20-16,
[data-color="category20-16"] {
	fill: #c7c7c7;
}
.category20-17,
[data-color="category20-17"] {
	fill: #bcbd22;
}
.category20-18,
[data-color="category20-18"] {
	fill: #dbdb8d;
}
.category20-19,
[data-color="category20-19"] {
	fill: #17becf;
}
.category20-20,
[data-color="category20-20"] {
	fill: #9edae5;
}

/* D3: category20b */
.category20b-1,
[data-color="category20b-1"] {
	fill: #393b79;
}
.category20b-2,
[data-color="category20b-2"] {
	fill: #5254a3;
}
.category20b-3,
[data-color="category20b-3"] {
	fill: #6b6ecf;
}
.category20b-4,
[data-color="category20b-4"] {
	fill: #9c9ede;
}
.category20b-5,
[data-color="category20b-5"] {
	fill: #637939;
}
.category20b-6,
[data-color="category20b-6"] {
	fill: #8ca252;
}
.category20b-7,
[data-color="category20b-7"] {
	fill: #b5cf6b;
}
.category20b-8,
[data-color="category20b-8"] {
	fill: #cedb9c;
}
.category20b-9,
[data-color="category20b-9"] {
	fill: #8c6d31;
}
.category20b-10,
[data-color="category20b-10"] {
	fill: #bd9e39;
}
.category20b-11,
[data-color="category20b-11"] {
	fill: #e7ba52;
}
.category20b-12,
[data-color="category20b-12"] {
	fill: #e7cb94;
}
.category20b-13,
[data-color="category20b-13"] {
	fill: #843c39;
}
.category20b-14,
[data-color="category20b-14"] {
	fill: #ad494a;
}
.category20b-15,
[data-color="category20b-15"] {
	fill: #d6616b;
}
.category20b-16,
[data-color="category20b-16"] {
	fill: #e7969c;
}
.category20b-17,
[data-color="category20b-17"] {
	fill: #7b4173;
}
.category20b-18,
[data-color="category20b-18"] {
	fill: #a55194;
}
.category20b-19,
[data-color="category20b-19"] {
	fill: #ce6dbd;
}
.category20b-20,
[data-color="category20b-20"] {
	fill: #de9ed6;
}

/* D3: category20c */
.category20c-1,
[data-color="category20c-1"] {
	fill: #3182bd;
}
.category20c-2,
[data-color="category20c-2"] {
	fill: #6baed6;
}
.category20c-3,
[data-color="category20c-3"] {
	fill: #9ecae1;
}
.category20c-4,
[data-color="category20c-4"] {
	fill: #c6dbef;
}
.category20c-5,
[data-color="category20c-5"] {
	fill: #e6550d;
}
.category20c-6,
[data-color="category20c-6"] {
	fill: #fd8d3c;
}
.category20c-7,
[data-color="category20c-7"] {
	fill: #fdae6b;
}
.category20c-8,
[data-color="category20c-8"] {
	fill: #fdd0a2;
}
.category20c-9,
[data-color="category20c-9"] {
	fill: #31a354;
}
.category20c-10,
[data-color="category20c-10"] {
	fill: #74c476;
}
.category20c-11,
[data-color="category20c-11"] {
	fill: #a1d99b;
}
.category20c-12,
[data-color="category20c-12"] {
	fill: #c7e9c0;
}
.category20c-13,
[data-color="category20c-13"] {
	fill: #756bb1;
}
.category20c-14,
[data-color="category20c-14"] {
	fill: #9e9ac8;
}
.category20c-15,
[data-color="category20c-15"] {
	fill: #bcbddc;
}
.category20c-16,
[data-color="category20c-16"] {
	fill: #dadaeb;
}
.category20c-17,
[data-color="category20c-17"] {
	fill: #636363;
}
.category20c-18,
[data-color="category20c-18"] {
	fill: #969696;
}
.category20c-19,
[data-color="category20c-19"] {
	fill: #bdbdbd;
}
.category20c-20,
[data-color="category20c-20"] {
	fill: #d9d9d9;
}





/* D3: Category10 */
.category10-1-span {
	background-color: #1f77b4;
}
.category10-2-span {
	background-color: #ff7f0e;
}
.category10-3-span {
	background-color: #2ca02c;
}
.category10-4-span {
	background-color: #d62728;
}
.category10-5-span {
	background-color: #9467bd;
}
.category10-6-span {
	background-color: #8c564b;
}
.category10-7-span {
	background-color: #e377c2;
}
.category10-8-span {
	background-color: #7f7f7f;
}
.category10-9-span {
	background-color: #bcdb22;
}
.category10-10-span {
	background-color: #17becf;
}

/* D3: category20 */
.category20-1-span {
	background-color: #1f77b4;
}
.category20-2-span {
	background-color: #aec7e8;
}
.category20-3-span {
	background-color: #ff7f0e;
}
.category20-4-span {
	background-color: #ffbb78;
}
.category20-5-span {
	background-color: #2ca02c;
}
.category20-6-span {
	background-color: #98df8a;
}
.category20-7-span {
	background-color: #d62728;
}
.category20-8-span {
	background-color: #ff9896;
}
.category20-9-span {
	background-color: #9467bd;
}
.category20-10-span {
	background-color: #c5b0d5;
}
.category20-11-span {
	background-color: #8c564b;
}
.category20-12-span {
	background-color: #c49c94;
}
.category20-13-span {
	background-color: #e377c2;
}
.category20-14-span {
	background-color: #f7b6d2;
}
.category20-15-span {
	background-color: #7f7f7f;
}
.category20-16-span {
	background-color: #c7c7c7;
}
.category20-17-span {
	background-color: #bcbd22;
}
.category20-18-span {
	background-color: #dbdb8d;
}
.category20-19-span {
	background-color: #17becf;
}
.category20-20-span {
	background-color: #9edae5;
}

/* D3: category20b */
.category20b-1-span {
	background-color: #393b79;
}
.category20b-2-span {
	background-color: #5254a3;
}
.category20b-3-span {
	background-color: #6b6ecf;
}
.category20b-4-span {
	background-color: #9c9ede;
}
.category20b-5-span {
	background-color: #637939;
}
.category20b-6-span {
	background-color: #8ca252;
}
.category20b-7-span {
	background-color: #b5cf6b;
}
.category20b-8-span {
	background-color: #cedb9c;
}
.category20b-9-span {
	background-color: #8c6d31;
}
.category20b-10-span {
	background-color: #bd9e39;
}
.category20b-11-span {
	background-color: #e7ba52;
}
.category20b-12-span {
	background-color: #e7cb94;
}
.category20b-13-span {
	background-color: #843c39;
}
.category20b-14-span {
	background-color: #ad494a;
}
.category20b-15-span {
	background-color: #d6616b;
}
.category20b-16-span {
	background-color: #e7969c;
}
.category20b-17-span {
	background-color: #7b4173;
}
.category20b-18-span {
	background-color: #a55194;
}
.category20b-19-span {
	background-color: #ce6dbd;
}
.category20b-20-span {
	background-color: #de9ed6;
}

/* D3: category20c */
.category20c-1-span {
	background-color: #3182bd;
}
.category20c-2-span {
	background-color: #6baed6;
}
.category20c-3-span {
	background-color: #9ecae1;
}
.category20c-4-span {
	background-color: #c6dbef;
}
.category20c-5-span {
	background-color: #e6550d;
}
.category20c-6-span {
	background-color: #fd8d3c;
}
.category20c-7-span {
	background-color: #fdae6b;
}
.category20c-8-span {
	background-color: #fdd0a2;
}
.category20c-9-span {
	background-color: #31a354;
}
.category20c-10-span {
	background-color: #74c476;
}
.category20c-11-span {
	background-color: #a1d99b;
}
.category20c-12-span {
	background-color: #c7e9c0;
}
.category20c-13-span {
	background-color: #756bb1;
}
.category20c-14-span {
	background-color: #9e9ac8;
}
.category20c-15-span {
	background-color: #bcbddc;
}
.category20c-16-span {
	background-color: #dadaeb;
}
.category20c-17-span {
	background-color: #636363;
}
.category20c-18-span {
	background-color: #969696;
}
.category20c-19-span {
	background-color: #bdbdbd;
}
.category20c-20-span {
	background-color: #d9d9d9;
}
</style>
		<style>:host {
	display: block;
	font-family: 'Open-Sans', sans-serif;
}

.noselect {
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}



</style>
		<style>
.canvas {
	display: block;
	margin: 0 auto;
}

.graph .hidden {
	opacity: 0;
}

.background {
	fill: #eee;
	stroke: none;
}

.grid {
	fill: none;
	stroke: #fff;
	stroke-width: 1;
	shape-rendering: crispEdges;
	vector-effect: non-scaling-stroke;
}

.name {
	cursor: pointer;
}

.active .name {
	fill: #ff0000;
}

.axis .label {
	font-size: 18px;
}
</style>
		<style>
/* MEDIA QUERIES */

/* 960 px */
@media screen and (max-width: 960px) {}
</style>

		<!-- PRESENTATION CONTENT -->
		<div class="chart" id="chart"></div>

	</template>

	<!-- REGISTRATION -->
	<script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
*
*	CHART
*
*
*	DESCRIPTION:
*		- Defines the chart prototype.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

/* global document */
'use strict';

// MODULES //

var // Utility to create delayed event listeners:
	delayed = require( './utils/delayed.js' );


// VARIABLES //

var EVENTS = [
	'data',
	'rowOrder',
	'colOrder',

	'width',
	'height',
	'zMin',
	'zMax',

	'changed',
	'err',

	'resized',

	'clicked',
	'clicked.row',
	'clicked.col',
	'clicked.cell',

	'hovered',
	'hovered.row',
	'hovered.col',
	'hovered.cell',

	'hoverended',
	'hoverended.row',
	'hoverended.col',
	'hoverended.cell',

	'transitionEnd'
];


// CHART //

/**
* FUNCTION: Chart()
*	Chart constructor.
*
* @constructor
* @returns {Chart} Chart instance
*/
function Chart() {
	if ( !( this instanceof Chart ) ) {
		return new Chart();
	}
	return this;
} // end FUNCTION Chart()

/**
* ATTRIBUTE: paddingLeft
*	Chart canvas left padding.
*
* @type {Null|Number}
* @default null
*/
Chart.prototype.paddingLeft = null;

/**
* ATTRIBUTE: paddingRight
*	Chart canvas right padding.
*
* @type {Null|Number}
* @default null
*/
Chart.prototype.paddingRight = null;

/**
* ATTRIBUTE: paddingBottom
*	Chart canvas bottom padding.
*
* @type {Null|Number}
* @default null
*/
Chart.prototype.paddingBottom = null;

/**
* ATTRIBUTE: paddingTop
*	Chart canvas top padding.
*
* @type {Null|Number}
* @default null
*/
Chart.prototype.paddingTop = null;

/**
* ATTRIBUTE: width
*	Chart canvas width. If not explicitly set, defaults to the width of the parent node.
*
* @type {Number}
* @default null
*/
Chart.prototype.width = null;

/**
* ATTRIBUTE: height
*	Chart canvas height. If not explicitly set, defaults to the height of the parent node.
*
* @type {Number}
* @default null
*/
Chart.prototype.height = null;

/**
* ATTRIBUTE: xLabel
*	Column label.
*
* @type {String}
* @default ''
*/
Chart.prototype.xLabel = '';

/**
* ATTRIBUTE: yLabel
*	Row label.
*
* @type {String}
* @default ''
*/
Chart.prototype.yLabel = '';

/**
* ATTRIBUTE: zValue
*	z-value accessor. If set to a function, the accessor is used to map z-values to a linear scale for fill-opacity.
*
* @type {Number|Function}
* @default 1
*/
Chart.prototype.zValue = 1;

/**
* ATTRIBUTE: zMin
*	Minimum z-limit. If `null`, the limit is computed from the data.
*
* @type {Null|Number}
* @default null
*/
Chart.prototype.zMin = null;

/**
* ATTRIBUTE: zMax
*	Maximum z-limit. If `null`, the limit is computed from the data.
*
* @type {Null|Number}
* @default null
*/
Chart.prototype.zMax = null;

/**
* METHOD: cScale( d, i )
*	Maps a cell datum to a color.
*
* @param {*} d - datum
* @param {Number} i - index
* @returns {String} color string
*/
Chart.prototype.cScale = function(){
	return '#eee';
}; // end METHOD cScale()

/**
* ATTRIBUTE: duration
*	Transition duration.
*
* @type {Number}
* @default 2500 milliseconds
*/
Chart.prototype.duration = 2500; // ms

/**
* ATTRIBUTE: autoUpdate
*	Boolean flag indicating whether a chart should auto update DOM elements whenever an attribute changes.
*
* @type {Boolean}
* @default true
*/
Chart.prototype.autoUpdate = true;

/**
* ATTRIBUTE: autoResize
*	Boolean flag indicating whether a chart should auto resize when the window resizes.
*
* @type {Boolean}
* @default true
*/
Chart.prototype.autoResize = true;

/**
* METHOD: created()
*	Polymer hook that is called when an element is created.
*/
Chart.prototype.created = function() {
	this.init();
}; // end METHOD created()

/**
* METHOD: init()
*	Initialization.
*/
Chart.prototype.init = function() {
	var create = document.createElement.bind( document ),
		d3,
		el,
		$;

	// Create a new D3 element to access the library dependency:
	el = create( 'polymer-d3' );
	d3 = el.d3;
	this._d3 = d3;

	// Create a new uuid element to access the library dependency for creating uuids:
	el = create( 'polymer-uuid' );
	this._uuid = el.uuid;

	// Assign the chart a private uuid:
	this.__uid__ = this._uuid.v4();

	// Initialize attributes...

	// Config: (hint an object)
	this.config = {};

	// Events: (hint an array)
	this.events = EVENTS;

	// Data:
	this.data = null;
	this.rowOrder = [];
	this.colOrder = [];
	this._rowOrder = null;
	this._colOrder = null;

	// Private attributes...

	// Row and column name font size:
	this._maxFontSize = 16; // px

	// Max row and column name lengths...
	this._maxRowTextLength = 0;
	this._maxColTextLength = 0;

	// Padding...
	this._minPadding = 40; // px
	this._paddingLeft = this._minPadding;
	this._paddingRight = this._minPadding;
	this._paddingTop = this._minPadding;
	this._paddingBottom = this._minPadding;

	// Private methods...

	// Scales...
	this._xScale = d3.scale.ordinal()
		.rangeBands( [ 0, this.graphWidth() ] )
		.domain( [ 0 ] );
	this._yScale = d3.scale.ordinal()
		.rangeBands( [ 0, this.graphHeight() ] )
		.domain( [ 0 ] );
	this._zScale = d3.scale.linear()
		.domain( [ 0, 1 ] )
		.range( [ 0, 1 ] )
		.clamp( true );

	// Labels:
	this._getRowName = this.getRowName.bind( this );
	this._getColName = this.getColName.bind( this );

	// Marks...
	this._x = this.x.bind( this );
	this._y = this.y.bind( this );
	this._z = this.z.bind( this );

	this._cx = this.cx.bind( this );

	this._createCells = this.createCells.bind( this );
	this._resetCells = this.resetCells.bind( this );

	// Transitions...
	this._onTransitionEnd = this.onTransitionEnd.bind( this );

	// Interaction...
	this._onRowHover = this.onRowHover.bind( this );
	this._onColHover = this.onColHover.bind( this );
	this._onCellHover = this.onCellHover.bind( this );

	this._onRowHoverEnd = this.onRowHoverEnd.bind( this );
	this._onColHoverEnd = this.onColHoverEnd.bind( this );
	this._onCellHoverEnd = this.onCellHoverEnd.bind( this );

	this._onRowClick = this.onRowClick.bind( this );
	this._onColClick = this.onColClick.bind( this );
	this._onCellClick = this.onCellClick.bind( this );

	this._onResize = delayed( this.onResize.bind( this ), 400 );

	// Element cache...
	this.$ = $ = {};

	// Base elements...
	$.root = null;
	$.canvas = null;
	$.graph = null;
	$.bkgd = null;
	$.text = null;

	// Axis elements...
	$.xAxis = null;
	$.yAxis = null;
	$.xLabel = null;
	$.yLabel = null;

	// Data elements...
	$.marks = null;
	$.rows = null;
	$.cols = null;
	$.cells = null;

	// Grid lines...
	$.rowGridlines = null;
	$.colGridlines = null;

	// Names...
	$.rownames = null;
	$.colnames = null;

	return this;
}; // end METHOD init()

/**
* METHOD: attached()
*	Polymer hook that is called when the element is inserted in the DOM.
*/
Chart.prototype.attached = function() {
	this.create().addListeners();
}; // end METHOD attached()

/**
* METHOD: detached()
*	Polymer hook that is called when the element is removed from the DOM.
*/
Chart.prototype.detached = function() {
	this.removeListeners();
}; // end METHOD detached()

/**
* METHOD: addListeners()
*	Adds event listeners.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.addListeners = function() {
	this.removeListeners();
	if ( this.autoResize ) {
		window.addEventListener( 'resize', this._onResize, false );
	}
	return this;
}; // end METHOD addListeners()

/**
* METHOD: removeListeners()
*	Removes event listeners.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.removeListeners = function() {
	window.removeEventListener( 'resize', this._onResize );
	return this;
}; // end METHOD removeListeners()

/**
* METHOD: create()
*	Creates a chart.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.create = function() {
	// Ensure that the width and height are set before creating a chart...
	this.width = this.width || this.clientWidth || this.parentNode.clientWidth || 600;
	this.height = this.height || this.clientHeight || this.parentNode.clientHeight || 400;

	// Create the chart layers...
	this
		.createBase()
		.createBackground()
		.createMarks()
		.createRows()
		.createCols()
		.createAxes();

	return this;
}; // end METHOD create()

/**
* METHOD: createBase()
*	Creates the chart base.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.createBase = function() {
	var pLeft,
		pTop,
		canvas;

	// Only cache the root element once (should not change)...
	if ( !this.$.root ) {
		this.$.root = this._d3.select( this.$.chart );
	}
	// Remove any existing canvas...
	if ( this.$.canvas ) {
		this.$.canvas.remove();
	}
	// Get the padding values:
	pLeft = ( this.paddingLeft === null ) ? this._paddingLeft : this.paddingLeft;
	pTop = ( this.paddingTop === null ) ? this._paddingTop : this.paddingTop;

	// Create the SVG element:
	canvas = this.$.root.append( 'svg:svg' )
		.attr( 'property', 'canvas' )
		.attr( 'class', 'canvas' )
		.attr( 'width', this.width )
		.attr( 'height', this.height );
	this.$.canvas = canvas;

	// Create the graph element:
	this.$.graph = canvas.append( 'svg:g' )
		.attr( 'property', 'graph' )
		.attr( 'class', 'graph' )
		.attr( 'data-graph-type', 'matrix-diagram' )
		.attr( 'transform', 'translate(' + pLeft + ',' + pTop + ')' );

	// Create a text element for auto-computing padding based on row and column names:
	this.$.text = canvas.append( 'svg:text' )
		.attr( 'class', 'noselect' )
		.attr( 'font-size', this._maxFontSize )
		.attr( 'x', 6 )
		.attr( 'y', 0 )
		.attr( 'dy', '.32em' )
		.attr( 'text-anchor', 'start' )
		.attr( 'opacity', 0 );

	this.$.text = this.$.text.node();

	return this;
}; // end METHOD createBase()

/**
* METHOD: createBackground()
*	Creates a background element.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.createBackground = function() {
	// Remove any existing background...
	if ( this.$.bkgd ) {
		this.$.bkgd.remove();
	}
	this.$.bkgd = this.$.graph.append( 'svg:rect' )
		.attr( 'class', 'background' )
		.attr( 'x', 0 )
		.attr( 'y', 0 )
		.attr( 'width', this.graphWidth() )
		.attr( 'height', this.graphHeight() );

	return this;
}; // end METHOD createBackground()

/**
* METHOD: createMarks()
*	Creates a graph marks element.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.createMarks = function() {
	if ( this.$.marks ) {
		this.$.marks.remove();
	}
	this.$.marks = this.$.graph.append( 'svg:g' )
		.attr( 'property', 'marks' )
		.attr( 'class', 'marks' );
	return this;
}; // end METHOD createMarks()

/**
* METHOD: createRows()
*	Creates row elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.createRows = function() {
	var rows = this.$.marks.selectAll( '.row' )
		.data( (this.data) ? this.data.rownames() : [] )
		.enter()
		.append( 'svg:g' )
			.attr( 'class', 'row' )
			.attr( 'transform', this._y )
			.on( 'mouseover', this._onRowHover )
			.on( 'mouseout', this._onRowHoverEnd );

	rows.append( 'svg:line' )
		.attr( 'class', 'grid x' )
		.attr( 'x1', this.graphWidth() );

	rows.append( 'svg:text' )
		.attr( 'class', 'noselect name' )
		.attr( 'x', -6 )
		.attr( 'y', this._yScale.rangeBand() / 2 )
		.attr( 'dy', '.32em' )
		.attr( 'text-anchor', 'end' )
		.attr( 'font-size', this.fontSize() )
		.text( this._getRowName )
		.on( 'click', this._onRowClick );

	// Cache references to created elements:
	this.$.rows = rows;
	this.$.rowGridlines = rows.selectAll( '.grid.x' );
	this.$.rownames = rows.selectAll( '.name' );

	// Create the row cells:
	rows.each( this._createCells );

	this.$.cells = rows.selectAll( '.cell' );

	return this;
}; // end METHOD createRows()

/**
* METHOD: createCols()
*	Creates column elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.createCols = function() {
	var cols = this.$.marks.selectAll( '.col' )
		.data( (this.data) ? this.data.colnames() :  [] )
		.enter()
		.append( 'svg:g' )
			.attr( 'class', 'col y' )
			.attr( 'transform', this._x )
			.on( 'mouseover', this._onColHover )
			.on( 'mouseout', this._onColHoverEnd );

	cols.append( 'svg:line' )
		.attr( 'class', 'grid y' )
		.attr( 'x1', -this.graphHeight() );

	cols.append( 'svg:text' )
		.attr( 'class', 'noselect name' )
		.attr( 'x', 6 )
		.attr( 'y', this._xScale.rangeBand() / 2 )
		.attr( 'dy', '.32em' )
		.attr( 'text-anchor', 'start' )
		.attr( 'font-size', this.fontSize() )
		.text( this._getColName )
		.on( 'click', this._onColClick );

	// Cache references to created elements:
	this.$.cols = cols;
	this.$.colGridlines = cols.selectAll( '.grid.y' );
	this.$.colnames = cols.selectAll( '.name' );

	return this;
}; // end METHOD createCols()

/**
* METHOD: createCells( d, i )
*	Create cell elements.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {DOMElement} element instance
*/
Chart.prototype.createCells = function( d, i ) {
	var row = this._d3.select( this.$.rows[0][i] );

	row.selectAll( '.cell' )
		.data( this.data.data()[i] )
		.enter()
		.append( 'svg:rect' )
			.attr( 'class', 'cell' )
			.attr( 'x', this._cx )
			.attr( 'width', this._xScale.rangeBand() )
			.attr( 'height', this._yScale.rangeBand() )
			.attr( 'fill-opacity', ( typeof this.zValue === 'function' ) ? this._z : this.zValue )
			.attr( 'fill', this.cScale )
			.on( 'mouseover', this._onCellHover )
			.on( 'mouseout', this._onCellHoverEnd )
			.on( 'click', this._onCellClick );

	return this;
}; // end METHOD createCells()

/**
* METHOD: createAxes()
*	Creates the chart axis elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.createAxes = function() {
	var graph = this.$.graph,
		axis;

	// Remove any existing axes...
	if ( this.$.xAxis ) {
		this.$.xAxis.remove();
	}
	if ( this.$.yAxis ) {
		this.$.yAxis.remove();
	}
	axis = graph.append( 'svg:g' )
		.attr( 'property', 'axis' )
		.attr( 'class', 'x axis' );
	this.$.xAxis = axis;

	this.$.xLabel = axis.append( 'svg:text' )
		.attr( 'property', 'axis.label' )
		.attr( 'class', 'label noselect' )
		.attr( 'text-anchor', 'middle' )
		.attr( 'x', this.graphWidth() / 2 )
		.attr( 'y', -(this._maxColTextLength+16) )
		.text( this.xLabel );

	axis = graph.append( 'svg:g' )
		.attr( 'property', 'axis' )
		.attr( 'class', 'y axis' );

	this.$.yLabel = axis.append( 'svg:text' )
		.attr( 'property', 'axis.label' )
		.attr( 'class', 'label noselect' )
		.attr( 'text-anchor', 'middle' )
		.attr( 'transform', 'rotate(-90)' )
		.attr( 'x', -this.graphHeight() / 2 )
		.attr( 'y', -(this._maxRowTextLength+16) )
		.text( this.xLabel );

	return this;
}; // end METHOD createAxes()

/**
* METHOD: reset()
*	Resets chart elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.reset = function() {
	this.resetBase()
		.resetAxes()
		.resetCols()
		.resetRows();
	return this;
}; // end METHOD reset()

/**
* METHOD: resetBase()
*	Resets base elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.resetBase = function() {
	var pLeft, pTop;

	pLeft = ( this.paddingLeft === null ) ? this._paddingLeft : this.paddingLeft;
	pTop = ( this.paddingTop === null ) ? this._paddingTop : this.paddingTop;

	this.$.graph
		.attr( 'transform', 'translate(' + pLeft + ',' + pTop + ')' );

	this.$.bkgd
		.attr( 'width', this.graphWidth() )
		.attr( 'height', this.graphHeight() );
	return this;
}; // end METHOD resetBase()

/**
* METHOD: resetAxes()
*	Resets axis elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.resetAxes = function() {
	this.$.xLabel
		.attr( 'x', this.graphWidth() / 2 )
		.attr( 'y', -(this._maxColTextLength+16) );

	this.$.yLabel
		.attr( 'x', -this.graphHeight() / 2 )
		.attr( 'y', -(this._maxRowTextLength+16) );

	return this;
}; // end METHOD resetAxes()

/**
* METHOD: resetRows()
*	Resets row elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.resetRows = function() {
	// Bind the data and update existing rows:
	var rows, gEnter;

	rows = this.$.marks.selectAll( '.row' )
		.data( this.data.rownames() )
		.attr( 'transform', this._y );

	// Remove any old rows:
	rows.exit().remove();

	// Add any new rows:
	gEnter = rows.enter().append( 'svg:g' )
		.attr( 'class', 'row' )
		.attr( 'transform', this._y )
		.on( 'mouseover', this._onRowHover )
		.on( 'mouseout', this._onRowHoverEnd );

	gEnter.append( 'svg:line' )
		.attr( 'class', 'grid x' )
		.attr( 'x1', this.graphWidth() );

	gEnter.append( 'svg:text' )
		.attr( 'class', 'noselect name' )
		.attr( 'x', -6 )
		.attr( 'y', this._yScale.rangeBand() / 2 )
		.attr( 'dy', '.32em' )
		.attr( 'text-anchor', 'end' )
		.attr( 'font-size', this.fontSize() )
		.text( this._getRowName )
		.on( 'click', this._onRowClick );

	// Update the cache references to row elements:
	this.$.rows = rows;
	this.$.rowGridlines = rows.selectAll( '.grid.x' );
	this.$.rownames = rows.selectAll( '.name' );

	// Create the row cells:
	rows.each( this._resetCells );

	this.$.cells = rows.selectAll( '.cell' );

	return this;
}; // end METHOD resetRows()

/**
* METHOD: resetCols()
*	Resets column elements.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.resetCols = function() {
	// Bind the data and update existing columns:
	var cols, gEnter;

	cols = this.$.marks.selectAll( '.col' )
		.data( this.data.colnames() )
		.attr( 'transform', this._x );

	// Remove any old columns:
	cols.exit().remove();

	// Add any new columns:
	gEnter = cols.enter().append( 'svg:g' )
		.attr( 'class', 'col' )
		.attr( 'transform', this._x )
		.on( 'mouseover', this._onColHover )
		.on( 'mouseout', this._onColHoverEnd );

	gEnter.append( 'svg:line' )
		.attr( 'class', 'grid y' )
		.attr( 'x1', -this.graphHeight() );

	gEnter.append( 'svg:text' )
		.attr( 'class', 'noselect name' )
		.attr( 'x', 6 )
		.attr( 'y', this._xScale.rangeBand() / 2 )
		.attr( 'dy', '.32em' )
		.attr( 'text-anchor', 'start' )
		.attr( 'font-size', this.fontSize() )
		.text( this._getColName )
		.on( 'click', this._onColClick );

	// Cache a reference to the columns:
	this.$.cols = cols;
	this.$.colGridlines = cols.selectAll( '.grid.y' );
	this.$.colnames = cols.selectAll( '.name' );

	return this;
}; // end METHOD resetCols()

/**
* METHOD: resetCells( d, i )
*	Resets cell elements.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {DOMElement} element instance
*/
Chart.prototype.resetCells = function( d, i ) {
	var row, cells;

	row = this._d3.select( this.$.rows[0][i] );

	cells = row.selectAll( '.cell' )
		.data( this.data.data()[i] )
		.attr( 'x', this._cx )
		.attr( 'fill-opacity', ( typeof this.zValue === 'function' ) ? this._z : this.zValue )
		.attr( 'fill', this.cScale );

	// Remove any old cells:
	cells.exit().remove();

	// Add any new cells:
	cells.enter().append( 'svg:rect' )
		.attr( 'class', 'cell' )
		.attr( 'x', this._cx )
		.attr( 'width', this._xScale.rangeBand() )
		.attr( 'height', this._yScale.rangeBand() )
		.attr( 'fill-opacity', ( typeof this.zValue === 'function' ) ? this._z : this.zValue )
		.attr( 'fill', this.cScale )
		.on( 'mouseover', this._onCellHover )
		.on( 'mouseout', this._onCellHoverEnd )
		.on( 'click', this._onCellClick );

	return this;
}; // end METHOD resetCells()

/**
* METHOD: clear()
*	Clears the chart.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.clear = function() {
	this.$.rows.remove();
	this.$.cols.remove();
	return this;
}; // end METHOD clear()

/**
* METHOD: graphWidth()
*	Returns the graph width.
*
* @returns {Number} graph width
*/
Chart.prototype.graphWidth = function() {
	var pLeft, pRight;

	pLeft = ( this.paddingLeft === null ) ? this._paddingLeft : this.paddingLeft;
	pRight = ( this.paddingRight === null ) ? this._paddingRight : this.paddingRight;

	return this.width - pLeft - pRight;
}; // end METHOD graphWidth()

/**
* METHOD: graphHeight()
*	Returns the graph height.
*
* @returns {Number} graph height
*/
Chart.prototype.graphHeight = function() {
	var pTop, pBottom;

	pTop = ( this.paddingTop === null ) ? this._paddingTop : this.paddingTop;
	pBottom = ( this.paddingBottom === null ) ? this._paddingBottom : this.paddingBottom;

	return this.height - pTop - pBottom;
}; // end METHOD graphHeight()

/**
* METHOD: x( d, i )
*	Maps a column to a pixel value.
*
* @param {Array} d - datum
* @param {Number} i - index
* @returns {String} transform string
*/
Chart.prototype.x = function( d, i ) {
	return 'translate(' + this._xScale( i ) + ')rotate(-90)';
}; // end METHOD x()

/**
* METHOD: y( d, i )
*	Maps a row to a pixel value.
*
* @param {Array} d - datum
* @param {Number} i - index
* @returns {String} transform string
*/
Chart.prototype.y = function( d, i ) {
	return 'translate(0,' + this._yScale( i ) + ')';
}; // end METHOD y()

/**
* METHOD: z( d, i )
*	Maps a datum to a fill-opacity value.
*
* @param {Array} d - datum
* @param {Number} i - index
* @returns {Number} fill opacity
*/
Chart.prototype.z = function( d, i ) {
	return this._zScale( this.zValue( d, i ) );
}; // end METHOD z()

/**
* METHOD: cx( d, i )
*	Maps a row cell to a pixel value.
*
* @param {Array} d - datum
* @param {Number} i - index
* @returns {String} transform string
*/
Chart.prototype.cx = function( d, i ) {
	return this._xScale( i );
}; // end METHOD cx()

/**
* METHOD: getRowName( d, i )
*	Returns a row name.
*
* @param {Array} d - datum
* @param {Number} i - index
* @returns {String} row name
*/
Chart.prototype.getRowName = function( d ) {
	return d;
}; // end METHOD getRowName()

/**
* METHOD: getColName( d, i )
*	Returns a column name.
*
* @param {Array} d - datum
* @param {Number} i - index
* @returns {String} column name
*/
Chart.prototype.getColName = function( d ) {
	return d;
}; // end METHOD getColName()

/**
* METHOD: zDomain( min, max )
*	Computes the z-domain.
*
* @param {Null|Number} min - minimum value
* @param {Null|Number} max - maximum value
* @returns {Array} domain
*/
Chart.prototype.zDomain = function( min, max ) {
	var d3 = this._d3,
		data = this.data.data(),
		zValue = this.zValue,
		err;

	if ( typeof zValue !== 'function' ) {
		return [ this.zMin, this.zMax ];
	}
	if ( min !== null && ( typeof min !== 'number' || min !== min ) ) {
		err = new TypeError( 'zDomain()::invalid input argument. Minimum value must be numeric or `null`. Value: `' + min + '`.' );
		this.fire( 'err', err );
		return;
	}
	if ( max !== null && ( typeof max !== 'number' || max !== max ) ) {
		err = new TypeError( 'zDomain()::invalid input argument. Maximum value must be numeric or `null`. Value: `' + max + '`.' );
		this.fire( 'err', err );
		return;
	}
	if ( min === null ) {
		min = d3.min( data, function onRow( row ) {
			return d3.min( row, zValue );
		});
	}
	if ( max === null ) {
		max = d3.max( data, function onRow( row ) {
			return d3.max( row, zValue );
		});
	}
	return [ min, max ];
}; // end METHOD zDomain()

/**
* METHOD: delay( d, i )
*	Computes the transition delay based on the element index.
*
* @param {*} d - datum
* @param {Number} i - index
* @returns {Number} transition delay in milliseconds
*/
Chart.prototype.delay = function( d, i ) {
	// NOTE: the scalar offset (e.g., 20) is something of a magic number, based more on feel than science.
	return i * 20;
}; // end METHOD delay()

/**
* METHOD: fontSize()
*	Computes the row and column label font size based on cell dimensions.
*
* @returns {Number} font size in pixels
*/
Chart.prototype.fontSize = function() {
	var dx, dy;
	dx = this._xScale.rangeBand();
	dy = this._yScale.rangeBand();
	if ( dx > dy ) {
		dx = dy;
	}
	if ( dx > 18 ) {
		// Return the font-size upper bound:
		return this._maxFontSize;
	}
	return dx - 2;
}; // end METHOD fontSize()

/**
* METHOD: calculatePadding()
*	Computes padding values based on row and column name computed text length.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.calculatePadding = function() {
	var text = this.$.text,
		min = this._minPadding,
		scalar = 16,
		names,
		max,
		len,
		h,
		i;

	// NOTE: the `scalar` is something of a magic number to avoid pushing up against the canvas edge and crowding axis labels.

	// Rows...
	names = this.data.rownames();

	max = min;
	for ( i = 0; i < names.length; i++ ) {
		text.textContent = names[ i ];
		len = text.getComputedTextLength();
		if ( len > max ) {
			max = len;
		}
	}
	h = this.$.yLabel.node().getBBox().height;
	if ( h ) {
		h += 10;
	}
	this._paddingLeft = Math.ceil( max+scalar+h );

	// Columns...
	names = this.data.colnames();

	max = min;
	for ( i = 0; i < names.length; i++ ) {
		text.textContent = names[ i ];
		len = text.getComputedTextLength();
		if ( len > max ) {
			max = len;
		}
	}
	h = this.$.xLabel.node().getBBox().height;
	if ( h ) {
		h += 10;
	}
	this._paddingTop = Math.ceil( max+scalar+h );

	// Reset the text content:
	text.textContent = '';

	return this;
}; // end METHOD calculatePadding()

/**
* METHOD: maxTextLengths()
*	Calculates the maximum row and column name lengths.
*
* @returns {DOMElement} element instance
*/
Chart.prototype.maxTextLengths = function() {
	var text = this.$.text,
		selection,
		names,
		max,
		len,
		i;

	if ( !this.data ) {
		return this;
	}
	selection = this._d3.select( text );

	// Base calculations on the actual name font-size:
	selection.attr( 'font-size', this.fontSize() );

	// Rows...
	names = this.data.rownames();

	max = 0;
	for ( i = 0; i < names.length; i++ ) {
		text.textContent = names[ i ];
		len = text.getComputedTextLength();
		if ( len > max ) {
			max = len;
		}
	}
	this._maxRowTextLength = Math.ceil( max );

	// Columns...
	names = this.data.colnames();

	max = 0;
	for ( i = 0; i < names.length; i++ ) {
		text.textContent = names[ i ];
		len = text.getComputedTextLength();
		if ( len > max ) {
			max = len;
		}
	}
	this._maxColTextLength = Math.ceil( max );

	// Restore the text font-size:
	selection.attr( 'font-size', this._maxFontSize );

	// Reset the text content:
	text.textContent = '';

	return this;
}; // end METHOD maxTextLengths()

/**
* METHOD: validateOrder( arr )
*	Validates that an array of indices is a permutation.
*
* @param {Array} arr - array of indices
* @returns {Boolean} boolean indicating if valid
*/
Chart.prototype.validateOrder = function( arr ) {
	var len = arr.length,
		hash = {},
		range,
		key,
		i;

	// Build a hash of all indices, ensuring uniqueness...
	for ( i = 0; i < len; i++ ) {
		key = arr[ i ];
		if ( hash[ key ] ) {
			return false;
		}
		hash[ key ] = true;
	}
	// Create a unique ordered array of all possible indices:
	range = this._d3.range( len );

	// Confirm that the hash has every possible index...
	for ( i = 0; i < len; i++ ) {
		if ( !hash[ range[i] ] ) {
			return false;
		}
	}
	return true;
}; // end METHOD validateOrder()

/**
* METHOD: dataChanged( oldVal newVal )
*	Event handler invoked when the `data` attribute changes.
*
* @param {Array} oldVal - old value
* @param {Array} newVal - new value
*/
Chart.prototype.dataChanged = function( oldVal, newVal ) {
	var range = this._d3.range,
		len;

	// TODO: check if data frame.

	// [0] Set the domains:
	len = this.data.colnames().length;
	this._xScale.domain( range( len ) );

	len = this.data.rownames().length;
	this._yScale.domain( range( len ) );

	this._zScale.domain( this.zDomain( this.zMin, this.zMax ) );

	// [1] Compute padding values based on the row and column names:
	this.calculatePadding();

	// [2] Update the scales:
	this._xScale.rangeBands( [ 0, this.graphWidth() ] );
	this._yScale.rangeBands( [ 0, this.graphHeight() ] );

	// [3] Compute max text lengths based on the row and column names:
	this.maxTextLengths();

	if ( this.autoUpdate ) {
		// [4] Reset elements:
		this.reset();
	}
	this.fire( 'data', {
		'type': 'changed'
	});
	this.fire( 'changed', {
		'attr': 'data',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD dataChanged()

/**
* METHOD: rowOrderChanged( val[, newVal] )
*	Event handler invoked when the `rowOrder` attribute changes.
*
* @param {Array} val - change event value
* @param {Array} [newVal] - new array of indices defining the row order
*/
Chart.prototype.rowOrderChanged = function( val, newVal ) {
	var len = this.data.rownames().length,
		rowOrder = this.rowOrder,
		selection,
		err;

	// Determine if we have a new row order array...
	if ( arguments.length > 1 && !Array.isArray( newVal ) ) {
		err = new TypeError( 'rowOrder::invalid assignment. Row order must be an array. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.rowOrder = val;
		return;
	}
	if ( rowOrder.length !== len ) {
		err = new Error( 'rowOrder::invalid assignment. Array length must equal the number of rows. Number of rows: ' + len + '.' );
		this.fire( 'err', err );
		this.rowOrder = this._rowOrder.slice();
		return;
	}
	if ( !this.validateOrder( rowOrder ) ) {
		err = new Error( 'rowOrder::invalid assignment. Assigned array must be a permutation of row indices.' );
		this.fire( 'err', err );
		this.rowOrder = this._rowOrder.slice();
		return;
	}
	this._rowOrder = rowOrder.slice();
	this._yScale.domain( rowOrder );

	if ( this.duration > 0 ) {
		selection = this.$.marks.transition()
			.duration( this.duration )
			.each( 'end', this._onTransitionEnd );

		selection.selectAll( '.row' )
			.delay( this.delay )
			.attr( 'transform', this._y );
	} else {
		this.$.rows.attr( 'transform', this._y );
		this.fire( 'transitionEnd', null );
	}
	this.fire( 'rowOrder', {
		'type': 'changed'
	});
	if ( newVal === void 0 ) {
		this.fire( 'changed', {
			'attr': 'rowOrder',
			'data': val[ 0 ]
		});
	} else {
		this.fire( 'changed', {
			'attr': 'rowOrder',
			'prev': val,
			'curr': newVal
		});
	}
}; // end METHOD rowOrderChanged()

/**
* METHOD: colOrderChanged( val[, newVal] )
*	Event handler invoked when the `colOrder` attribute changes.
*
* @param {Array} val - change event value
* @param {Array} [newVal] - new array of indices defining the column order
*/
Chart.prototype.colOrderChanged = function( val, newVal ) {
	var len = this.data.colnames().length,
		colOrder = this.colOrder,
		selection,
		err;

	// Determine if we have a new row order array...
	if ( arguments.length > 1 && !Array.isArray( newVal ) ) {
		err = new TypeError( 'colOrder::invalid assignment. Row order must be an array. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.colOrder = val;
		return;
	}
	if ( colOrder.length !== len ) {
		err = new Error( 'colOrder::invalid assignment. Array length must equal the number of columns. Number of columns: ' + len + '.' );
		this.fire( 'err', err );
		this.colOrder = this._colOrder.slice();
		return;
	}
	if ( !this.validateOrder( colOrder ) ) {
		err = new Error( 'colOrder::invalid assignment. Assigned array must be a permutation of column indices.' );
		this.fire( 'err', err );
		this.colOrder = this._colOrder.slice();
		return;
	}
	this._colOrder = colOrder.slice();
	this._xScale.domain( colOrder );

	if ( this.duration > 0 ) {
		selection = this.$.marks.transition()
			.duration( this.duration )
			.each( 'end', this._onTransitionEnd );

		selection.selectAll( '.col' )
			.delay( this.delay )
			.attr( 'transform', this._x );

		selection.selectAll( '.row' )
			.selectAll( '.cell' )
			.delay( this.delay )
			.attr( 'x', this._cx );
	} else {
		this.$.cols.attr( 'transform', this._x );

		this.$.cells.attr( 'x', this._cx );

		this.fire( 'transitionEnd', null );
	}
	this.fire( 'colOrder', {
		'type': 'changed'
	});
	if ( newVal === void 0 ) {
		this.fire( 'changed', {
			'attr': 'colOrder',
			'data': val[ 0 ]
		});
	} else {
		this.fire( 'changed', {
			'attr': 'colOrder',
			'prev': val,
			'curr': newVal
		});
	}
}; // end METHOD colOrderChanged()

/**
* METHOD: configChanged( oldConfig, newConfig )
*	Event handler invoked when the `config` attribute changes.
*
* @param {Object} oldConfig - old config
* @param {Object} newConfig - new config
*/
Chart.prototype.configChanged = function( oldConfig, newConfig ) {
	var bool,
		err;

	if ( typeof newConfig !== 'object' || newConfig === null || Array.isArray( newConfig) ) {
		err = new TypeError( 'config::invalid assignment. Must be an `object`. Value: `' + newConfig + '`.' );
		this.fire( 'err', err );
		this.config = oldConfig;
		return;
	}
	// TODO: schema validator

	// Turn off auto-update:
	bool = this.autoUpdate;
	this.autoUpdate = false;

	// this.width = newConfig.canvas.width;
	// this.height = newConfig.canvas.height;

	// FIXME: The config should be standardized. Put in repo. Version it. Create an associated validator. NPM.

	this.fire( 'changed', {
		'attr': 'config',
		'prev': oldConfig,
		'curr': newConfig
	});

	// Reset the auto update flag to its original value:
	this.autoUpdate = bool;

	// Only if auto update is enabled, redraw the chart...
	if ( bool ) {
		this.create();
	}
}; // end METHOD configChanged()

/**
* METHOD: widthChanged( oldVal, newVal )
*	Event handler invoked when the `width` attribute changes.
*
* @param {Number} oldVal - old value
* @param {Number} newVal - new value
*/
Chart.prototype.widthChanged = function( oldVal, newVal ) {
	var width,
		fontSize,
		dx,
		err;
	if ( typeof newVal !== 'number' || newVal !== newVal || newVal <= 0 ) {
		err = new TypeError( 'width::invalid assignment. Must be a number greater than 0. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.width = oldVal;
		return;
	}
	width = this.graphWidth();

	// [0] Update the x-scale:
	this._xScale.rangeBands( [ 0, width ] );

	// [1] Recompute the row and column name text lengths:
	this.maxTextLengths();

	if ( this.$.canvas && this.autoUpdate ) {
		dx = this._xScale.rangeBand();
		fontSize = this.fontSize();

		// [2] Update the SVG canvas:
		this.$.canvas
			.attr( 'width', newVal );

		// [3] Update the background:
		this.$.bkgd
			.attr( 'width', width );

		// [4] Update the rows:
		this.$.rowGridlines
			.attr( 'x1', width );

		// [5] Update the columns:
		this.$.cols
			.attr( 'transform', this._x );

		// [6] Update the cells:
		this.$.cells
			.attr( 'x', this._cx )
			.attr( 'width', dx );

		// [7] Update the row and column names:
		this.$.rownames
			.attr( 'y', this._yScale.rangeBand() / 2 )
			.attr( 'font-size', fontSize );

		this.$.colnames
			.attr( 'y', dx / 2 )
			.attr( 'font-size', fontSize );

		// [8] Update the x- and y-labels:
		this.$.xLabel
			.attr( 'x', width / 2 )
			.attr( 'y', -(this._maxColTextLength+16) );

		this.$.yLabel
			.attr( 'y', -(this._maxRowTextLength+16) );
	}
	this.fire( 'width', {
		'type': 'changed'
	});
	this.fire( 'changed', {
		'attr': 'width',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD widthChanged()

/**
* METHOD: heightChanged( oldVal, newVal )
*	Event handler invoked when the `height` attribute changes.
*
* @param {Number} oldVal - old value
* @param {Number} newVal - new value
*/
Chart.prototype.heightChanged = function( oldVal, newVal ) {
	var height,
		fontSize,
		dy,
		err;
	if ( typeof newVal !== 'number' || newVal !== newVal || newVal <= 0 ) {
		err = new TypeError( 'height::invalid assignment. Must be a number greater than 0. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.height = oldVal;
		return;
	}
	height = this.graphHeight();

	// [0] Update the y-scale:
	this._yScale.rangeBands( [ 0, height ] );

	// [1] Recompute the row and column name text lengths:
	this.maxTextLengths();

	if ( this.$.canvas && this.autoUpdate ) {
		dy = this._yScale.rangeBand();
		fontSize = this.fontSize();

		// [2] Update the SVG canvas:
		this.$.canvas
			.attr( 'height', newVal );

		// [3] Update the background:
		this.$.bkgd
			.attr( 'height', height );

		// [4] Update the rows:
		this.$.rows
			.attr( 'transform', this._y );

		// [5] Update the columns:
		this.$.colGridlines
			.attr( 'x1', -height );

		// [6] Update the cells:
		this.$.cells
			.attr( 'height', dy );

		// [7] Update the row and column names:
		this.$.rownames
			.attr( 'y', dy / 2 )
			.attr( 'font-size', fontSize );

		this.$.colnames
			.attr( 'y', this._xScale.rangeBand() / 2 )
			.attr( 'font-size', fontSize );

		// [8] Update the x- and y-labels:
		this.$.xLabel
			.attr( 'y', -(this._maxColTextLength+16) );

		this.$.yLabel
			.attr( 'x', -height / 2 )
			.attr( 'y', -(this._maxRowTextLength+16) );
	}
	this.fire( 'height', {
		'type': 'changed'
	});
	this.fire( 'changed', {
		'attr': 'height',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD heightChanged()

/**
* METHOD: paddingLeftChanged( oldVal, newVal )
*	Event handler invoked when the `paddingLeft` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.paddingLeftChanged = function( oldVal, newVal ) {
	var width,
		pLeft,
		pRight,
		pTop,
		fontSize,
		dx,
		err;
	if ( newVal !== null && (typeof newVal !== 'number' || newVal !== newVal || newVal%1 !== 0 || newVal < 0) ) {
		err = new TypeError( 'paddingLeft::invalid assignment. Must be null or an integer greater than or equal to 0. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.paddingLeft = oldVal;
		return;
	}
	pLeft = ( newVal === null ) ? this._paddingLeft : newVal;
	pRight = ( this.paddingRight === null ) ? this._paddingRight : this.paddingRight;
	pTop = ( this.paddingTop === null ) ? this._paddingTop : this.paddingTop;

	width = this.width - pLeft - pRight;

	// [0] Update the x-scale:
	this._xScale.rangeBands( [ 0, width ] );

	// [1] Recompute the row and column name text lengths:
	this.maxTextLengths();

	if ( this.autoUpdate ) {
		dx = this._xScale.rangeBand();
		fontSize = this.fontSize();

		// [2] Update the background:
		this.$.bkgd
			.attr( 'width', width );

		// [3] Update the graph:
		this.$.graph
			.attr( 'transform', 'translate(' + pLeft + ',' + pTop + ')' );

		// [4] Update the rows:
		this.$.rowGridlines
			.attr( 'x1', width );

		// [5] Update the columns:
		this.$.cols
			.attr( 'transform', this._x );

		// [6] Update the cells:
		this.$.cells
			.attr( 'x', this._cx )
			.attr( 'width', dx );

		// [7] Update the row and column names:
		this.$.rownames
			.attr( 'y', this._yScale.rangeBand() / 2 )
			.attr( 'font-size', fontSize );

		this.$.colnames
			.attr( 'y', dx / 2 )
			.attr( 'font-size', fontSize );

		// [8] Update the x- and y-labels:
		this.$.xLabel
			.attr( 'x', width / 2 )
			.attr( 'y', -(this._maxColTextLength+16) );

		this.$.yLabel
			.attr( 'y', -(this._maxRowTextLength+16) );
	}
	this.fire( 'changed', {
		'attr': 'paddingLeft',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD paddingLeftChanged()

/**
* METHOD: paddingRightChanged( oldVal, newVal )
*	Event handler invoked when the `padding` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.paddingRightChanged = function( oldVal, newVal ) {
	var width,
		fontSize,
		dx,
		err;
	if ( newVal !== null && (typeof newVal !== 'number' || newVal !== newVal || newVal%1 !== 0 || newVal < 0) ) {
		err = new TypeError( 'paddingRight::invalid assignment. Must be null or an integer greater than or equal to 0. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.paddingRight = oldVal;
		return;
	}
	width = this.graphWidth();

	// [0] Update the x-scale:
	this._xScale.rangeBands( [ 0, width ] );

	// [1] Recompute the row and column name text lengths:
	this.maxTextLengths();

	if ( this.autoUpdate ) {
		dx = this._xScale.rangeBand();
		fontSize = this.fontSize();

		// [2] Update the background:
		this.$.bkgd
			.attr( 'width', width );

		// [3] Update the rows:
		this.$.rowGridlines
			.attr( 'x1', width );

		// [4] Update the columns:
		this.$.cols
			.attr( 'transform', this._x );

		// [5] Update the cells:
		this.$.cells
			.attr( 'x', this._cx )
			.attr( 'width', dx );

		// [6] Update the row and column names:
		this.$.rownames
			.attr( 'y', this._yScale.rangeBand() / 2 )
			.attr( 'font-size', fontSize );

		this.$.colnames
			.attr( 'y', dx / 2 )
			.attr( 'font-size', fontSize );

		// [7] Update the x- and y-labels:
		this.$.xLabel
			.attr( 'x', width / 2 )
			.attr( 'y', -(this._maxColTextLength+16) );

		this.$.yLabel
			.attr( 'y', -(this._maxRowTextLength+16) );
	}
	this.fire( 'changed', {
		'attr': 'paddingRight',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD paddingRightChanged()

/**
* METHOD: paddingBottomChanged( oldVal, newVal )
*	Event handler invoked when the `paddingBottom` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.paddingBottomChanged = function( oldVal, newVal ) {
	var height,
		fontSize,
		dy,
		err;
	if ( newVal !== null && (typeof newVal !== 'number' || newVal !== newVal || newVal%1 !== 0 || newVal < 0) ) {
		err = new TypeError( 'paddingBottom::invalid assignment. Must be null or an integer greater than or equal to 0. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.paddingBottom = oldVal;
		return;
	}
	height = this.graphHeight();

	// [0] Update the y-scale:
	this._yScale.rangeBands( [ 0, height ] );

	// [1] Recompute the row and column name text lengths:
	this.maxTextLengths();

	if ( this.autoUpdate ) {
		dy = this._yScale.rangeBand();
		fontSize = this.fontSize();

		// [2] Update the background:
		this.$.bkgd
			.attr( 'height', height );

		// [3] Update the rows:
		this.$.rows
			.attr( 'transform', this._y );

		// [4] Update the columns:
		this.$.colGridlines
			.attr( 'x1', -height );

		// [5] Update the cells:
		this.$.cells
			.attr( 'height', dy );

		// [6] Update the row and column names:
		this.$.rownames
			.attr( 'y', dy / 2 )
			.attr( 'font-size', fontSize );

		this.$.colnames
			.attr( 'y', this._xScale.rangeBand() / 2 )
			.attr( 'font-size', fontSize );

		// [7] Update the x- and y-labels:
		this.$.xLabel
			.attr( 'y', -(this._maxColTextLength+16) );

		this.$.yLabel
			.attr( 'x', -height / 2 )
			.attr( 'y', -(this._maxRowTextLength+16) );
	}
	this.fire( 'changed', {
		'attr': 'paddingBottom',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD paddingBottomChanged()

/**
* METHOD: paddingTopChanged( oldVal, newVal )
*	Event handler invoked when the `paddingTop` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.paddingTopChanged = function( oldVal, newVal ) {
	var height,
		pLeft,
		pTop,
		pBottom,
		fontSize,
		dy,
		err;
	if ( newVal !== null && (typeof newVal !== 'number' || newVal !== newVal || newVal%1 !== 0 || newVal < 0) ) {
		err = new TypeError( 'paddingTop::invalid assignment. Must be null or an integer greater than or equal to 0.  Value: `' + newVal + '.' );
		this.fire( 'err', err );
		this.paddingTop = oldVal;
		return;
	}
	pTop = ( newVal === null ) ? this._paddingTop : newVal;
	pBottom = ( this.paddingBottom === null ) ? this._paddingBottom : this.paddingBottom;
	pLeft = ( this.paddingLeft === null ) ? this._paddingLeft : this.paddingLeft;

	height = this.height - pTop - pBottom;

	// [0] Update the y-scale:
	this._yScale.rangeBands( [ 0, height ] );

	// [1] Recompute the row and column name text lengths:
	this.maxTextLengths();

	if ( this.autoUpdate ) {
		dy = this._yScale.rangeBand();
		fontSize = this.fontSize();

		// [2] Update the background:
		this.$.bkgd
			.attr( 'height', height );

		// [3] Update the graph:
		this.$.graph
			.attr( 'transform', 'translate(' + pLeft + ',' + pTop + ')' );

		// [4] Update the rows:
		this.$.rows
			.attr( 'transform', this._y );

		// [5] Update the columns:
		this.$.colGridlines
			.attr( 'x1', -height );

		// [6] Update the cells:
		this.$.cells
			.attr( 'height', dy );

		// [7] Update the row and column labels:
		this.$.rownames
			.attr( 'y', dy / 2 )
			.attr( 'font-size', fontSize );

		this.$.colnames
			.attr( 'y', this._xScale.rangeBand() / 2 )
			.attr( 'font-size', fontSize );

		// [8] Update the x- and y-labels:
		this.$.xLabel
			.attr( 'y', -(this._maxColTextLength+16) );

		this.$.yLabel
			.attr( 'x', -height / 2 )
			.attr( 'y', -(this._maxRowTextLength+16) );
	}
	this.fire( 'changed', {
		'attr': 'paddingTop',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD paddingTopChanged()

/**
* METHOD: zValueChanged( oldVal, newVal )
*	Event handler invoked when the `zValue` attribute changes.
*
* @param {Function|Number} oldVal - old value
* @param {Function|Number} newVal - new value
*/
Chart.prototype.zValueChanged = function( oldVal, newVal ) {
	var type = typeof newVal,
		err;
	if ( type !== 'function' && ( type !== 'number' || newVal !== newVal || newVal < 0 || newVal > 1 ) ) {
		err = new TypeError( 'zValue::invalid assignment. Must be either a function or a numeric value between 0 and 1. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.zValue = oldVal;
		return;
	}
	if ( type === 'function' ) {
		this._zScale.domain( this.zDomain( this.zMin, this.zMax ) );
	}
	if ( this.autoUpdate ) {
		this.$.cells.attr( 'fill-opacity', ( typeof this.zValue === 'function' ) ? this._z : this.zValue );
	}
	this.fire( 'changed', {
		'attr': 'zValue',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD zValueChanged()

/**
* METHOD: zMinChanged( oldVal, newVal )
*	Event handler invoked when the `zMin` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.zMinChanged = function( oldVal, newVal ) {
	var zScale = this._zScale,
		domain = zScale.domain(),
		err;

	if ( newVal !== null && (typeof newVal !== 'number' || newVal !== newVal) ) {
		err = new TypeError( 'zMin::invalid assignment. Must be a numeric or `null`. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.zMin = oldVal;
		return;
	}
	domain = this.zDomain( newVal, domain[ 1 ] );

	zScale.domain( domain );

	if ( this.autoUpdate ) {
		this.$.cells.attr( 'fill-opacity', ( typeof this.zValue === 'function' ) ? this._z : this.zValue );
	}
	this.fire( 'zMin', {
		'type': 'changed'
	});
	this.fire( 'changed', {
		'attr': 'zMin',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD zMinChanged()

/**
* METHOD: zMaxChanged( oldVal, newVal )
*	Event handler invoked when the `zMax` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.zMaxChanged = function( oldVal, newVal ) {
	var zScale = this._zScale,
		domain = zScale.domain(),
		err;

	if ( newVal !== null && (typeof newVal !== 'number' || newVal !== newVal) ) {
		err = new TypeError( 'zMax::invalid assignment. Must be a numeric or `null`. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.zMax = oldVal;
		return;
	}
	domain = this.zDomain( domain[ 0 ], newVal );

	zScale.domain( domain );

	if ( this.autoUpdate ) {
		this.$.cells.attr( 'fill-opacity', ( typeof this.zValue === 'function' ) ? this._z : this.zValue );
	}
	this.fire( 'zMax', {
		'type': 'changed'
	});
	this.fire( 'changed', {
		'attr': 'zMax',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD zMaxChanged()

/**
* METHOD: cScaleChanged( oldVal, newVal )
*	Event handler invoked when the `cScale` attribute changes.
*
* @param {Number} oldVal - old value
* @param {Number} newVal - new value
*/
Chart.prototype.cScaleChanged = function( oldVal, newVal ) {
	var err;
	if ( typeof newVal !== 'function' ) {
		err = new TypeError( 'cScale::invalid assignment. Must be a function.  Value: `' + newVal + '.' );
		this.fire( 'err', err );
		this.cScale = oldVal;
		return;
	}
	if ( this.autoUpdate ) {
		this.$.cells.attr( 'fill', newVal );
	}
	this.fire( 'changed', {
		'attr': 'cScale',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD cScaleChanged()

/**
* METHOD: xLabelChanged( oldVal, newVal )
*	Event handler invoked when the `xLabel` attribute changes.
*
* @param {String} oldVal - old value
* @param {String} newVal - new value
*/
Chart.prototype.xLabelChanged = function( oldVal, newVal ) {
	var height,
		fontSize,
		dy,
		err;
	if ( typeof newVal !== 'string' ) {
		err = new TypeError( 'xlabel::invalid assignment. Must be a string. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.xLabel = oldVal;
		return;
	}
	if ( this.autoUpdate ) {
		// [0] Set the label text:
		this.$.xLabel.text( newVal );

		// Only recompute the layout if label changed to or from an empty string...
		if ( !oldVal || !newVal ) {
			// [1] Compute the padding based on the row and column text lengths:
			this.calculatePadding();
			height = this.graphHeight();

			// [2] Update the y-scale:
			this._yScale.rangeBands( [ 0, height ] );

			dy = this._yScale.rangeBand();
			fontSize = this.fontSize();

			// [3] Compute the max row and column text lengths:
			this.maxTextLengths();

			// [4] Update the background:
			this.$.bkgd
				.attr( 'height', height );

			// [5] Update the graph:
			this.$.graph
				.attr( 'transform', 'translate(' + this._paddingLeft + ',' + this._paddingTop + ')' );

			// [6] Update the rows:
			this.$.rows
				.attr( 'transform', this._y );

			// [7] Update the columns:
			this.$.colGridlines
				.attr( 'x1', -height );

			// [8] Update the cells:
			this.$.cells
				.attr( 'height', dy );

			// [9] Update the row and column labels:
			this.$.rownames
				.attr( 'y', dy / 2 )
				.attr( 'font-size', fontSize );

			this.$.colnames
				.attr( 'y', this._xScale.rangeBand() / 2 )
				.attr( 'font-size', fontSize );

			// [10] Update the x- and y-labels:
			this.$.xLabel
				.attr( 'y', -(this._maxColTextLength+16) );

			this.$.yLabel
				.attr( 'x', -height / 2 )
				.attr( 'y', -(this._maxRowTextLength+16) );
		}
	}
	this.fire( 'changed', {
		'attr': 'xLabel',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD xLabelChanged()

/**
* METHOD: yLabelChanged( oldVal, newVal )
*	Event handler invoked when the `yLabel` attribute changes.
*
* @param {String} oldVal - old value
* @param {String} newVal - new value
*/
Chart.prototype.yLabelChanged = function( oldVal, newVal ) {
	var width,
		fontSize,
		dx,
		err;
	if ( typeof newVal !== 'string' ) {
		err = new TypeError( 'yLabel::invalid assignment. Must be a string. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.yLabel = oldVal;
		return;
	}
	if ( this.autoUpdate ) {
		// [0] Set the label text:
		this.$.yLabel.text( newVal );

		// Only recompute the layout if label changed to or from an empty string...
		if ( !oldVal || !newVal ) {
			// [1] Compute the padding based on the row and column text lengths:
			this.calculatePadding();
			width = this.graphWidth();

			// [2] Update the x-scale:
			this._xScale.rangeBands( [ 0, width ] );

			dx = this._xScale.rangeBand();
			fontSize = this.fontSize();

			// [3] Compute the max row and column text lengths:
			this.maxTextLengths();

			// [4] Update the background:
			this.$.bkgd
				.attr( 'width', width );

			// [5] Update the graph:
			this.$.graph
				.attr( 'transform', 'translate(' + this._paddingLeft + ',' + this._paddingTop + ')' );

			// [6] Update the rows:
			this.$.rowGridlines
				.attr( 'x1', width );

			// [7] Update the columns:
			this.$.cols
				.attr( 'transform', this._x );

			// [8] Update the cells:
			this.$.cells
				.attr( 'x', this._cx )
				.attr( 'width', dx );

			// [9] Update the row and column names:
			this.$.rownames
				.attr( 'y', this._yScale.rangeBand() / 2 )
				.attr( 'font-size', fontSize );

			this.$.colnames
				.attr( 'y', dx / 2 )
				.attr( 'font-size', fontSize );

			// [10] Update the x- and y-labels:
			this.$.xLabel
				.attr( 'x', width / 2 )
				.attr( 'y', -(this._maxColTextLength+16) );

			this.$.yLabel
				.attr( 'y', -(this._maxRowTextLength+16) );
		}
	}
	this.fire( 'changed', {
		'attr': 'yLabel',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD yLabelChanged()

/**
* METHOD: durationChanged( oldVal, newVal )
*	Event handler invoked when the `duration` attribute changes.
*
* @param {Null|Number} oldVal - old value
* @param {Null|Number} newVal - new value
*/
Chart.prototype.durationChanged = function( oldVal, newVal ) {
	var err;
	if ( typeof newVal !== 'number' || newVal !== newVal ) {
		err = new TypeError( 'duration::invalid assignment. Must be a numeric. Value: `' + newVal + '`.' );
		this.fire( 'err', err );
		this.duration = oldVal;
		return;
	}
	this.fire( 'changed', {
		'attr': 'duration',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD durationChanged()

/**
* METHOD: autoUpdateChanged( oldVal, newVal )
*	Event handler invoked when the `autoUpdate` attribute changes.
*
* @param {Boolean} oldVal - old value
* @param {Boolean} newVal - new value
*/
Chart.prototype.autoUpdateChanged = function( oldVal, newVal ) {
	var err;
	if ( typeof newVal !== 'boolean' ) {
		err = new TypeError( 'autoUpdate::invalid assignment. Must be a boolean.  Value: `' + newVal + '.' );
		this.fire( 'err', err );
		this.autoUpdate = oldVal;
		return;
	}
	this.fire( 'changed', {
		'attr': 'autoUpdate',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD autoUpdateChanged()

/**
* METHOD: autoResizeChanged( oldVal, newVal )
*	Event handler invoked when the `autoResize` attribute changes.
*
* @param {Boolean} oldVal - old value
* @param {Boolean} newVal - new value
*/
Chart.prototype.autoResizeChanged = function( oldVal, newVal ) {
	var err;
	if ( typeof newVal !== 'boolean' ) {
		err = new TypeError( 'autoResize::invalid assignment. Must be a boolean.  Value: `' + newVal + '.' );
		this.fire( 'err', err );
		this.autoResize = oldVal;
		return;
	}
	if ( newVal ) {
		window.addEventListener( 'resize', this._onResize, false );
	} else {
		window.removeEventListener( 'resize', this._onResize );
	}
	this.fire( 'changed', {
		'attr': 'autoResize',
		'prev': oldVal,
		'curr': newVal
	});
}; // end METHOD autoResizeChanged()

/**
* METHOD: onRowClick( d, i )
*	Click listener for rows.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {Boolean} false
*/
Chart.prototype.onRowClick = function( d, i ) {
	var evt = this._d3.event;
	evt.datum = d;
	evt.index = i;
	this.fire( 'clicked.row', evt );
	this.fire( 'clicked', evt );
	return false;
}; // end METHOD onRowClick()

/**
* METHOD: onColClick( d, i )
*	Click listener for columns.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {Boolean} false
*/
Chart.prototype.onColClick = function( d, i ) {
	var evt = this._d3.event;
	evt.datum = d;
	evt.index = i;
	this.fire( 'clicked.col', evt );
	this.fire( 'clicked', evt );
	return false;
}; // end METHOD onColClick()

/**
* METHOD: onCellClick( d, i )
*	Click listener for cells.
*
* @param {String} d - cell data
* @param {Number} i - cell index
* @returns {Boolean} false
*/
Chart.prototype.onCellClick = function( d, i ) {
	var evt = this._d3.event,
		rows = this.$.rows[ 0 ],
		row,
		j;

	evt.datum = d;
	evt.col = i;

	// Determine the row index...
	row = evt.path[ 1 ];
	for ( j = 0; j < rows.length; j++ ) {
		if ( rows[ j ] === row ) {
			break;
		}
	}
	evt.row = j;

	this.fire( 'clicked.cell', evt );
	this.fire( 'clicked', evt );
	return false;
}; // end METHOD onCellClick()

/**
* METHOD: onRowHover( d, i )
*	Mouseover listener for rows.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {Boolean} false
*/
Chart.prototype.onRowHover = function( d, i ) {
	var evt = this._d3.event;

	this.$.rows[ 0 ][ i ].classList.add( 'active' );

	evt.datum = d;
	evt.index = i;
	this.fire( 'hovered.row', evt );
	this.fire( 'hovered', evt );
	return false;
}; // end METHOD onRowHover()

/**
* METHOD: onColHover( d, i )
*	Mouseover listener for columns.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {Boolean} false
*/
Chart.prototype.onColHover = function( d, i ) {
	var evt = this._d3.event;

	this.$.cols[ 0 ][ i ].classList.add( 'active' );

	evt.datum = d;
	evt.index = i;
	this.fire( 'hovered.col', evt );
	this.fire( 'hovered', evt );
	return false;
}; // end METHOD onColHover()

/**
* METHOD: onCellHover( d, i )
*	Mouseover listener for cells.
*
* @param {String} d - cell data
* @param {Number} i - cell index
* @returns {Boolean} false
*/
Chart.prototype.onCellHover = function( d, i ) {
	var evt = this._d3.event,
		rows = this.$.rows[ 0 ],
		row,
		j;

	this.$.cols[ 0 ][ i ].classList.add( 'active' );

	evt.datum = d;
	evt.col = i;

	// Determine the row index...
	row = evt.path[ 1 ];
	for ( j = 0; j < rows.length; j++ ) {
		if ( rows[ j ] === row ) {
			break;
		}
	}
	evt.row = j;

	this.fire( 'hovered.cell', evt );
	this.fire( 'hovered', evt );
	return false;
}; // end METHOD onCellHover()

/**
* METHOD: onRowHoverEnd( d, i )
*	Mouseout listener for rows.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {Boolean} false
*/
Chart.prototype.onRowHoverEnd = function( d, i ) {
	var evt = this._d3.event;

	this.$.rows[ 0 ][ i ].classList.remove( 'active' );

	evt.datum = d;
	evt.index = i;
	this.fire( 'hoverended.row', evt );
	this.fire( 'hoverended', evt );
	return false;
}; // end METHOD onRowHoverEnd()

/**
* METHOD: onColHoverEnd( d, i )
*	Mouseout listener for columns.
*
* @param {String} d - row name
* @param {Number} i - row index
* @returns {Boolean} false
*/
Chart.prototype.onColHoverEnd = function( d, i ) {
	var evt = this._d3.event;

	this.$.cols[ 0 ][ i ].classList.remove( 'active' );

	evt.datum = d;
	evt.index = i;
	this.fire( 'hoverended.col', evt );
	this.fire( 'hoverended', evt );
	return false;
}; // end METHOD onColHoverEnd()

/**
* METHOD: onCellHoverEnd( d, i )
*	Mouseout listener for cells.
*
* @param {String} d - cell data
* @param {Number} i - cell index
* @returns {Boolean} false
*/
Chart.prototype.onCellHoverEnd = function( d, i ) {
	var evt = this._d3.event,
		rows = this.$.rows[ 0 ],
		row,
		j;

	this.$.cols[ 0 ][ i ].classList.remove( 'active' );

	evt.datum = d;
	evt.col = i;

	// Determine the row index...
	row = evt.path[ 1 ];
	for ( j = 0; j < rows.length; j++ ) {
		if ( rows[ j ] === row ) {
			break;
		}
	}
	evt.row = j;

	this.fire( 'hoverended.cell', evt );
	this.fire( 'hoverended', evt );
	return false;
}; // end METHOD onCellHoverEnd()

/**
* METHOD: onTransitionEnd()
*	Event listener for transition `end` events.
*
* @returns {Boolean} false
*/
Chart.prototype.onTransitionEnd = function() {
	this.fire( 'transitionEnd', null );
	return false;
}; // end METHOD onTransitionEnd()

/**
* METHOD: onResize()
*	Resize listener.
*/
Chart.prototype.onResize = function() {
	this.fire( 'resized', {
		'el': 'polymer-matrix-diagram',
		'msg': 'Received a resize event.'
	});
	if ( !this.$.canvas ) {
		return;
	}
	this.width = this.clientWidth;
}; // end METHOD onResize()


// EXPORTS //

module.exports = Chart;

},{"./utils/delayed.js":3}],2:[function(require,module,exports){
/**
*
*	COMPONENT: polymer-matrix-diagram
*
*
*	DESCRIPTION:
*		- Registers the polymer-matrix-diagram web-component.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

/* global Polymer */
'use strict';

// MODULES //

var Chart = require( './chart.js' );


// POLYMER //

Polymer( 'polymer-matrix-diagram', Chart.prototype );

},{"./chart.js":1}],3:[function(require,module,exports){
/**
*
*	UTILS: delayed
*
*
*	DESCRIPTION:
*		- Throttles an event listener by delaying its invocation until after all events have finished firing.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

/**
* FUNCTION: delayed( fcn, delay )
*	Returns a function that fires after the end of an event. A `delay` parameter specifies the interval between when the event was last triggered and when the end listener should be fired (i.e., a form of throttling).
*
* @param {Function} fcn - function to fire at the end of an event
* @param {Number} delay - millisecond delay to impose for function invocation
* @returns {Function} delayed function
*/
function delayed( fcn, delay ) {
	var timeout;
	if ( typeof fcn !== 'function' ) {
		throw new TypeError( 'delayed()::invalid input argument. First argument must be a function.' );
	}
	if ( typeof delay !== 'number' || delay !== delay || delay < 0 ) {
		throw new TypeError( 'delayed()::invalid input argument. Second argument must be a number greater than 0.' );
	}
	return function delayed() {
		var args;
		if ( timeout ) {
			clearTimeout( timeout );
			timeout = setTimeout( later, delay );
		}
		args = arguments;

		// Set a timeout for when the function can be invoked:
		timeout = setTimeout( later, delay );

		function later() {
			timeout = null;
			fcn.apply( null, args );
		}
	};
} // end FUNCTION delayed()


// EXPORTS //

module.exports = delayed;

},{}]},{},[2]);
</script>

</polymer-element>
</body></html>